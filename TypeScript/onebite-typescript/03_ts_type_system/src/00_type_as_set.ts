/**
 * =====================================================================
 * TypeScript: "νƒ€μ…μ€ μ§‘ν•©μ΄λ‹¤" (Type Compatibility) - Executable Note
 * =====================================================================
 * β… ν•µμ‹¬ κ°λ… (Set Theory)
 * 1. νƒ€μ…(Type) = "κ°’λ“¤μ μ§‘ν•©"
 *    - number νƒ€μ… = λ¨λ“  μ«μμ μ§‘ν•© (Infinite Set)
 *    - λ¦¬ν„°λ΄ νƒ€μ…(10) = λ”± 10 ν•λ‚λ§ μλ” μ§‘ν•© (Singleton Set)
 *
 * 2. νƒ€μ… νΈν™μ„±(Compatibility) = "ν¬ν•¨ κ΄€κ³„(Subset)"
 *    - "λ¶€λ¶„μ§‘ν•©(μ‘μ€ μ§‘ν•©)μ€ μƒμ„μ§‘ν•©(ν° μ§‘ν•©)μ— λ“¤μ–΄κ° μ μλ‹¤." (μ—…μΊμ¤ν… β…)
 *    - "μƒμ„μ§‘ν•©(ν° μ§‘ν•©)μ€ λ¶€λ¶„μ§‘ν•©(μ‘μ€ μ§‘ν•©)μ— μ–µμ§€λ΅ λ„£μ„ μ μ—†λ‹¤." (λ‹¤μ΄μΊμ¤ν… β)
 *
 * π”¥ κ³µμ‹
 * - λ¶€λ¨(ν° μ§‘ν•©) = μμ‹(μ‘μ€ μ§‘ν•©)  --> OK (μ•μ „ν•¨)
 * - μμ‹(μ‘μ€ μ§‘ν•©) = λ¶€λ¨(ν° μ§‘ν•©)  --> Error (λ¶μ•μ „ν•¨)
 */

console.clear?.();

// ---------------------------------------------------------------------
// 1) λ¦¬ν„°λ΄ νƒ€μ…κ³Ό μνΌ νƒ€μ… (λ¶€λ¶„μ§‘ν•© κ΄€κ³„)
// ---------------------------------------------------------------------
{
   // number: μ„Έμƒ λ¨λ“  μ«μλ¥Ό ν¬ν•¨ν•λ” "ν° μ§‘ν•©" (μνΌ νƒ€μ…)
   let numSet: number = 100;

   // 10: μ¤μ§ μ«μ 10λ§ ν¬ν•¨ν•λ” "μ‘μ€ μ§‘ν•©" (μ„λΈ νƒ€μ…/λ¦¬ν„°λ΄ νƒ€μ…)
   let num10: 10 = 10;

   // β… μ—…μΊμ¤ν… (Upcasting): μ‘μ€ μ§‘ν•© -> ν° μ§‘ν•© (κ°€λ¥)
   // 10μ΄λΌλ” κ°’μ€ number μ§‘ν•©μ— ν¬ν•¨λλ―€λ΅ μ•μ „ν•¨!
   numSet = num10;
   console.log('μ—…μΊμ¤ν… μ„±κ³µ:', numSet);

   // β λ‹¤μ΄μΊμ¤ν… (Downcasting): ν° μ§‘ν•© -> μ‘μ€ μ§‘ν•© (λ¶κ°€λ¥)
   // number(λ¨λ“  μ«μ)κ°€ 10(μ¤μ§ 10)μ•μ— λ“¤μ–΄κ° μ μ—†μ.
   // (μ: 100μ€ 10μ΄ μ•„λ‹λ‹κΉ)
   // num10 = numSet; // Error: Type 'number' is not assignable to type '10'.
}

// ---------------------------------------------------------------------
// 2) μ λ‹μ¨(Union) νƒ€μ… = ν•©μ§‘ν•© (Union Set, β)
// ---------------------------------------------------------------------
{
   // A μ§‘ν•©: string
   // B μ§‘ν•©: number
   // Union: A β B (λ‘ λ‹¤ ν¬ν•¨ν•λ” λ” ν° μ§‘ν•©)
   let unionSet: string | number;

   let s: string = 'hello';
   let n: number = 123;

   // β… λ¶€λ¶„μ§‘ν•©λ“¤μ€ ν•©μ§‘ν•©μ— λ“¤μ–΄κ° μ μλ‹¤.
   unionSet = s; // string β‚ (string | number)
   unionSet = n; // number β‚ (string | number)

   console.log('μ λ‹μ¨ ν• λ‹Ή μ™„λ£:', unionSet);

   // β λ°λ€λ” μ•λ¨
   // (string | number)λ” λ„λ¬΄ μ»¤μ„ stringμ΄λΌλ” μ‘μ€ λ°©μ— λ» λ“¤μ–΄κ°
   // s = unionSet; // Error
}

// ---------------------------------------------------------------------
// 3) μΈν„°μ„Ήμ…(Intersection) νƒ€μ… = κµμ§‘ν•© (Intersection Set, β©)
// ---------------------------------------------------------------------
{
   // κ°μ²΄μ—μ„μ κµμ§‘ν•©μ€ "μ†μ„±μ„ λ¨λ‘ κ°€μ§„ κ²ƒ"μ„ μλ―Έν•¨
   type Dog = { name: string; bark: () => void };
   type Cat = { name: string; meow: () => void };

   // Dogμ΄λ©΄μ„ λ™μ‹μ— Catμ΄μ–΄μ•Ό ν•¨ (μ†μ„±μ΄ ν•©μ³μ§)
   // β οΈ μ£Όμ: νƒ€μ…μ κµμ§‘ν•©μ€ μ†μ„±(Property) κΈ°μ¤€μΌλ΅λ” ν•©μ§‘ν•©μ²λΌ λ™μ‘ν•¨
   type DogCat = Dog & Cat;

   const hybrid: DogCat = {
      name: 'κ°λƒ¥μ΄',
      bark: () => console.log('λ©λ©'),
      meow: () => console.log('μ•ΌμΉ'),
   };

   // β… DogCatμ€ Dogμ λ¨λ“  κ²ƒμ„ κ°€μ§€κ³  μμΌλ―€λ΅ Dogμ— ν• λ‹Ή κ°€λ¥
   const onlyDog: Dog = hybrid;

   console.log('κµμ§‘ν•© κ°μ²΄:', hybrid.name);
}

// ---------------------------------------------------------------------
// 4) νΉμν• μ§‘ν•©λ“¤ (μ „μ²΄ μ§‘ν•© & κ³µμ§‘ν•©)
// ---------------------------------------------------------------------
{
   /**
    * unknown: "μ „μ²΄ μ§‘ν•©" (Universal Set)
    * - λ¨λ“  κ°’μ΄ λ“¤μ–΄κ° μ μλ” κ°€μ¥ ν° μ§‘ν•©
    */
   let universe: unknown;
   universe = 1; // OK
   universe = 'hello'; // OK
   universe = true; // OK

   // λ‹¨, unknownμ€ λ„λ¬΄ μ»¤μ„ λ‹¤λ¥Έ μ‘μ€ μ§‘ν•©(number λ“±)μ—” λ» λ“¤μ–΄κ° (μ•μ „μ¥μΉ)
   // let a: number = universe; // Error

   /**
    * never: "κ³µμ§‘ν•©" (Empty Set, Γ)
    * - μ•„λ¬΄κ²ƒλ„ λ“¤μ–΄μ¬ μ μ—†λ” κ°€μ¥ μ‘μ€ μ§‘ν•©
    * - μ£Όλ΅ "λ¶κ°€λ¥ν• μƒν™©"μ΄λ‚ "μ—λ¬"λ¥Ό ν‘ν„ν•  λ• μ‚¬μ©
    */
   // let nothing: never = 1; // Error: κ·Έ μ–΄λ–¤ κ°’λ„ neverμ— ν• λ‹Ή λ¶κ°€
   // let nothing: never = null; // Error
   // let nothing: never = undefined; // Error

   // neverλ” κ°€μ¥ μ‘μΌλ―€λ΅, μ–΄λ””λ“  λ“¤μ–΄κ° μ μμ (κ³µμ§‘ν•©μ€ λ¨λ“  μ§‘ν•©μ λ¶€λ¶„μ§‘ν•©)
   let n: number;
   // n = (never νƒ€μ… λ³€μ); // μ΄λ΅ μƒ κ°€λ¥
}
