# TypeScript 개론 README (Onebite TypeScript) 📘

> 이 문서는 **한 입 크기로 잘라먹는 타입스크립트(winterlood / 이정환)**의 개론 파트를 학습용으로 요약한 README입니다.  
> (참고한 페이지: “타입스크립트 소개”, “JS의 단점과 TS의 장점”, “TS 동작 원리”, “컴파일러 옵션 설정”)

---

## ✅ 맨 위에 적어둘 “진짜 중요한 것” ⭐🔥

1) **TypeScript는 실행 언어가 아니다.**  
   TS는 컴파일 단계에서 **타입 검사**를 하고, 최종 결과는 **JavaScript로 변환**되어 브라우저/Node에서 실행된다.

2) **TS는 런타임 버그를 0으로 만들지 않는다.**  
   TS는 “타입 실수”를 강하게 줄여주지만, **API 응답/사용자 입력** 같은 런타임 데이터는 별도 검증이 필요할 수 있다.

3) **핵심 효용: 리팩토링/협업 안전망**  
   프로젝트가 커질수록 “실행 전에 잡히는 오류”의 가치가 급상승한다.

4) **현업 체감 포인트는 `strict` + (좁히기, 제네릭, 유틸리티 타입)**  
   문법 외우기보다, **에러가 왜 뜨는지**를 이해하는 게 성장 속도가 빠르다.

---

## 1) 타입스크립트란?

TypeScript는 **JavaScript의 확장판**이다.

- JS 문법을 그대로 쓰면서
- “타입”을 추가해서
- 실행 전에 오류를 더 빨리 발견하게 해준다.

---

## 2) JS의 단점과 TS의 장점 (타입 시스템 관점)

### 타입 시스템이란?
언어에서:
- 어떤 값들을 “타입”으로 묶을지
- 타입을 **언제/어떻게 검사할지**
정해둔 규칙들의 묶음.

### 동적 타입 (JavaScript)
- 타입이 **실행 중에** 결정됨
- 유연하고 빠르게 짤 수 있음
- 단점: 실행 중 예상치 못한 타입 때문에 **런타임 에러**가 늦게 터질 수 있음

예)
- 어떤 변수에 처음엔 문자열이 들어왔다가, 나중에 숫자가 들어가면
- 문자열 전용 메서드를 호출하는 순간 런타임에서 터짐

### 정적 타입 (많은 전통 언어)
- 타입을 **실행 전에** 확정하고 검사
- 초반엔 귀찮아도, 규모가 커질수록 안정성이 큼

### TypeScript (점진적 타이핑)
- 정적 타입처럼 실행 전에 검사하면서도
- 필요한 부분만 점진적으로 타입을 붙일 수 있음(추론 + 명시)

---

## 3) 타입스크립트는 어떻게 동작할까? ⚙️🔥

대부분 언어의 컴파일 흐름은 대략:

1. 코드 → AST(추상 문법 트리)로 변환  
2. AST → 실행 가능한 형태(바이트코드/기계어 등)로 변환  
3. 실행

TypeScript는 중간이 다름:

1. TS 코드 → AST 변환  
2. **타입 검사(Type Checking)** 수행  
3. 타입 검사 통과 시 AST → **JavaScript 코드로 변환**  
4. 그 JS를 Node/브라우저가 실행

👉 결론: TS는 “실행”이 아니라 **검사 + 변환**이 핵심이다.

---

## 4) 컴파일러 옵션(tsconfig.json) 정리 🧩

TypeScript는 프로젝트(패키지) 루트에 `tsconfig.json`을 두고, 여기서 컴파일러 동작을 조절한다.

### 4.1 tsconfig 자동 생성
```bash
npx tsc --init
```

### 4.2 수동으로 잡을 때 가장 중요한 옵션들

#### ✅ include
컴파일할 파일 범위를 지정한다.

```json
{
  "include": ["src/**/*"]
}
```

#### ✅ target
컴파일 결과 JS 버전(ES5, ESNext 등)을 정한다.

- 학습/최신 환경: `ESNext`
- 구형 환경 대응: `ES5` 등

#### ✅ module
모듈 시스템(CommonJS, ESNext 등)을 정한다.

- Node + ESM: `ESNext` (+ package.json `"type": "module"` 조합)
- Node + CommonJS: `CommonJS`

#### ✅ outDir
컴파일 결과물이 생성될 폴더를 지정한다.

```json
{
  "compilerOptions": {
    "outDir": "dist"
  }
}
```

#### ✅ strict
타입 검사 엄격도를 결정한다.

- `strict: true`면 더 많은 오류를 컴파일 단계에서 잡아준다.
- 초반에는 불편하지만, 실력 상승에 매우 도움된다(추천 ⭐).

#### ✅ moduleDetection (force)
각 파일을 “모듈”로 취급할지 자동 처리하는 옵션.

- 여러 파일에서 같은 변수명을 쓰면 전역 취급 때문에 충돌할 수 있는데,
- `moduleDetection: "force"`는 파일을 독립 모듈로 취급하게 도와준다.

#### (Deprecated) ts-node 옵션
- 강의에서도 언급되듯, **tsx를 쓰는 경우 스킵해도 됨**
- ts-node는 ESM 설정이 까다로운 편이라, 학습 단계에선 `tsx`가 보통 더 편하다.

---

## 5) 지금 네 section1 환경에 맞춘 “추천 tsconfig” ✅

현재 상황(대부분 학습용)은:
- `src/` 안에 TS 파일
- 컴파일 결과는 `dist/`로
- ESM 기반(module: ESNext)
- VSCode 경고 방지 위해 `rootDir`/`outDir` 명시

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "rootDir": "./src",
    "outDir": "./dist",
    "skipLibCheck": true,
    "moduleDetection": "force"
  },
  "include": ["src/**/*"]
}
```

> `strict`는 초반에 빨간줄이 늘어나지만, “실수 패턴”을 빨리 교정해주는 최고의 트레이너다 🥊

---

## 6) 실행/컴파일 루틴 (가장 무난) 🚀

### 컴파일
```bash
npx tsc
```

### 실행
```bash
node dist/index.js
```

### (선택) tsx로 바로 실행(추천)
```bash
npm i -D tsx
npx tsx src/index.ts
```

---

## ✅ 핵심 요약 12개 (암기용 체크리스트) 🧠

1. TS는 JS 확장판이고, 최종 실행은 JS가 한다.  
2. TS 컴파일에는 타입 검사가 포함된다.  
3. TS는 런타임 버그를 모두 막지 못한다(입력/응답 검증은 별개).  
4. 동적 타입(JS)은 유연하지만 런타임 에러가 늦게 터질 수 있다.  
5. TS는 실행 전에 오류를 잡아 디버깅 비용을 줄인다.  
6. `tsconfig.json`은 프로젝트 단위로 적용된다.  
7. `include`는 컴파일 대상 범위를 정한다.  
8. `target`은 JS 출력 버전을 정한다.  
9. `module`은 모듈 시스템을 정한다.  
10. `outDir`은 결과물 출력 폴더다.  
11. `strict`는 타입 검사 엄격도, 실력 상승에 매우 좋다 ⭐  
12. `tsx`는 설정이 간단해 학습용으로 특히 편하다.

---

## 📎 참고(원문 기반)
- TypeScript 소개 / 타입 시스템 / 동작 원리 / 컴파일러 옵션 설정(한 입 크기 TS 핸드북)
