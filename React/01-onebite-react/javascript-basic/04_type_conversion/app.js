/**
 * =====================================================================
 * JavaScript Basic: 형 변환 (Type Conversion) - 학습+실무 템플릿
 * =====================================================================
 * ⭐ = 실무 빈출 / 🔥 = 면접/핵심 / 🛡️ = 방어적 코딩
 *
 * [핵심 요약]
 * 1. 초급: 숫자와 문자를 더하면 문자가 된다. (묵시적 변환)
 * 2. 중급: 변환은 Number(), String() 처럼 '명시적'으로 하는 게 좋다.
 * 3. 고급: parseInt는 '10px'도 숫자로 읽지만, Number는 NaN을 뱉는다.
 * 4. 실무패턴: 단항 연산자 `+`를 쓰면 가장 짧고 빠르게 숫자로 바뀐다. ⭐
 */

console.clear?.();

// 🛠️ [Helper] 출력용 유틸리티 함수 (이게 있어야 아래 코드가 돌아갑니다!)
const line = (title) => {
   console.log('--------------------------------------------------');
   if (title) console.log(`▶ ${title}`);
};

// =====================================================================
// 1) [초급] 묵시적 형 변환: JS의 "과한 친절" (함정 주의 🛡️)
// =====================================================================
{
   line('1. 묵시적 형 변환 (Implicit)');

   let num = 10;
   let str = '20';

   // 🔥 함정: 더하기(+)는 문자열 연결이 우선권을 가짐
   // "숫자 10"이 "문자 10"으로 변해서 연결됨
   const result = num + str;
   console.log(`10 + '20' = ${result} (Type: ${typeof result})`); // "1020"

   // 💡 반전: 빼기, 곱하기, 나누기는 숫자가 우선권을 가짐
   // "문자 20"이 "숫자 20"으로 변해서 계산됨
   console.log(`'20' - 10 = ${str - num}`); // 10
}

// =====================================================================
// 2) [중급] 문자열 -> 숫자 변환 (String to Number) ⭐
// =====================================================================
{
   line('2. 문자열 -> 숫자 (명시적 변환)');

   let str1 = '10';
   let str2 = '10.5px';

   // 방법 1: Number() 생성자 (가장 정석, 엄격함)
   let strToNum = Number(str1);
   console.log(`Number('10') + 10 = ${strToNum + 10}`); // 20

   // 방법 2: parseInt() / parseFloat() (유연함)
   // 🔥 차이점: Number()는 문자가 섞이면 NaN이지만, parseInt는 숫자만 읽음
   console.log(`Number('10.5px') = ${Number(str2)}`); // NaN
   console.log(`parseInt('10.5px') = ${parseInt(str2)}`); // 10 (정수)
   console.log(`parseFloat('10.5px') = ${parseFloat(str2)}`); // 10.5 (실수)

   // 방법 3: 단항 연산자 '+' (실무 최선호 ⭐)
   // 가장 코드가 짧아서 리액트 props 넘길 때 많이 씀
   console.log(`+'20' = ${+'20'} (Type: ${typeof +'20'})`);
}

// =====================================================================
// 3) [고급] 숫자 -> 문자열 변환 (Number to String)
// =====================================================================
{
   line('3. 숫자 -> 문자열 (명시적 변환)');

   let num1 = 20;

   // 방법 1: String() 생성자
   let numToStr = String(num1);

   // 방법 2: .toString() 메서드 (null/undefined는 사용 불가 주의 🛡️)
   let numToStr2 = num1.toString();

   // 방법 3: 빈 문자열 더하기 (가장 빠름 🔥)
   let numToStr3 = num1 + '';

   console.log(`String(20): "${numToStr}"`);
   console.log(`(20).toString(): "${numToStr2}"`);
   console.log(`20 + "": "${numToStr3}"`);
}

// =====================================================================
// 4) [실무패턴] 🛡️ 방어적 코딩: "NaN"을 조심해라
// =====================================================================
{
   line('4. 방어적 코딩 (Defensive Coding)');

   // 사용자 입력이 엉망일 때 (예: 숫자에 "abc" 입력)
   let dirtyInput = 'abc';
   let converted = Number(dirtyInput); // NaN

   // ❌ NaN은 자기 자신과도 같지 않음 (NaN === NaN -> false)
   if (converted === NaN) {
      console.log('이 로그는 절대 찍히지 않습니다.');
   }

   // ✅ 올바른 검사법: isNaN() 또는 Number.isNaN() 사용 ⭐
   if (Number.isNaN(converted)) {
      console.log('🚨 잘못된 숫자 입력입니다! (0으로 초기화합니다)');
      converted = 0;
   }
}

// =====================================================================
// 5) [핵심정리] 복습 체크리스트 10개 ✅
// =====================================================================
/*
    1. 형 변환은 '묵시적(자동)'과 '명시적(수동)'이 있다. 🔥
    2. 묵시적 변환은 편리하지만 예기치 않은 버그(특히 +연산)를 만든다. 🛡️
    3. 더하기(+) 연산자는 문자열이 우선이다. ("1" + 1 = "11") ⭐
    4. 빼기/곱하기/나누기 연산자는 숫자가 우선이다. ("10" - 2 = 8)
    5. 문자열을 숫자로 바꿀 땐 `Number()`, `parseInt()`, `+` 를 쓴다. ⭐
    6. `parseInt`는 "10px" 같은 단위가 붙은 문자열 처리에 유리하다.
    7. `parseFloat`은 소수점까지 유지하고 싶을 때 사용한다.
    8. 실무에서는 코드 길이를 줄이기 위해 `+변수` (단항 연산자)를 많이 쓴다. 🔥
    9. 숫자를 문자열로 바꿀 땐 `String()`이나 `변수 + ""`를 쓴다.
    10. 변환 실패 시 `NaN`이 나오며, 검사는 반드시 `Number.isNaN()`으로 해야 한다. 🛡️
*/
